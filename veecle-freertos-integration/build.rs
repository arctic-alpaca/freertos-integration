//! Build script for the FreeRTOS Rust library to emit `cfg`s for conditional compilation depending on the
//! `FreeRTOSConfig.h` configuration.
use std::path::PathBuf;
use std::{env, fs};

use regex::Regex;

/// Environment variable to locate FreeRTOS bindings generated by `veecle-freertos-sys`.
const FREERTOS_BINDINGS_LOCATION_ENV_KEY: &str = "DEP_FREERTOS_FREERTOS_BINDINGS_LOCATION";

/// All configuration options that are either `0` or `1`.
const BOOLEAN_CONFIGS: &[&str] = &[
    "configAPPLICATION_ALLOCATED_HEAP",
    "configASSERT_DEFINED",
    "configCHECK_HANDLER_INSTALLATION",
    "configENABLE_ACCESS_CONTROL_LIST",
    "configENABLE_BACKWARD_COMPATIBILITY",
    "configENABLE_FPU",
    "configENABLE_HEAP_PROTECTOR",
    "configENABLE_MPU",
    "configENABLE_MVE",
    "configENABLE_TRUSTZONE",
    "configGENERATE_RUN_TIME_STATS",
    "configIDLE_SHOULD_YIELD",
    "configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS",
    "configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H",
    "configKERNEL_PROVIDED_STATIC_MEMORY",
    "configPRECONDITION_DEFINED",
    "configRECORD_STACK_HIGH_ADDRESS",
    "configRUN_ADDITIONAL_TESTS",
    "configRUN_FREERTOS_SECURE_ONLY",
    "configRUN_MULTIPLE_PRIORITIES",
    "configSUPPORT_DYNAMIC_ALLOCATION",
    "configSUPPORT_STATIC_ALLOCATION",
    "configUSE_16_BIT_TICKS",
    // Alternative API was remove in FreeRTOS v9.0.0.
    "configUSE_ALTERNATIVE_API",
    "configUSE_APPLICATION_TASK_TAG",
    "configUSE_CORE_AFFINITY",
    "configUSE_CO_ROUTINES",
    "configUSE_COUNTING_SEMAPHORES",
    "configUSE_C_RUNTIME_TLS_SUPPORT",
    "configUSE_DAEMON_TASK_STARTUP_HOOK",
    "configUSE_EVENT_GROUPS",
    "configUSE_IDLE_HOOK",
    "configUSE_MALLOC_FAILED_HOOK",
    "configUSE_MINI_LIST_ITEM",
    "configUSE_MPU_WRAPPERS_V1",
    "configUSE_MUTEXES",
    "configUSE_NEWLIB_REENTRANT",
    "configUSE_PASSIVE_IDLE_HOOK",
    "configUSE_PICOLIBC_TLS",
    "configUSE_PORT_OPTIMISED_TASK_SELECTION",
    "configUSE_POSIX_ERRNO",
    "configUSE_PREEMPTION",
    "configUSE_QUEUE_SETS",
    "configUSE_RECURSIVE_MUTEXES",
    "configUSE_SB_COMPLETED_CALLBACK",
    "configUSE_STREAM_BUFFERS",
    "configUSE_TASK_NOTIFICATIONS",
    "configUSE_TASK_PREEMPTION_DISABLE",
    "configUSE_TICK_HOOK",
    "configUSE_TICKLESS_IDLE",
    "configUSE_TIMERS",
    "configUSE_TIME_SLICING",
    "configUSE_TRACE_FACILITY",
    "INCLUDE_eTaskGetState",
    "INCLUDE_uxTaskGetStackHighWaterMark",
    "INCLUDE_uxTaskGetStackHighWaterMark2",
    "INCLUDE_uxTaskPriorityGet",
    "INCLUDE_vTaskDelay",
    // "INCLUDE_xTaskDelayUntil" replaced vTaskDelayUntil in V10.4.2.
    "INCLUDE_vTaskDelayUntil",
    "INCLUDE_vTaskDelete",
    "INCLUDE_vTaskPrioritySet",
    "INCLUDE_vTaskSuspend",
    "INCLUDE_xQueueGetMutexHolder",
    // Same value as `INCLUDE_xQueueGetMutexHolder`.
    "INCLUDE_xSemaphoreGetMutexHolder",
    "INCLUDE_xTaskAbortDelay",
    "INCLUDE_xTaskDelayUntil",
    "INCLUDE_xTaskGetCurrentTaskHandle",
    "INCLUDE_xTaskGetHandle",
    "INCLUDE_xTaskGetIdleTaskHandle",
    "INCLUDE_xTaskGetSchedulerState",
    "INCLUDE_xTaskResumeFromISR",
    "INCLUDE_xTimerPendFunctionCall",
];

/// All configuration options using a set of predetermined values.
/// Configuration options that are not limited to a set of values like "configCPU_CLOCK_HZ" will not be included.
const VALUE_CONFIGS: &[(&str, &[u64])] = &[
    ("configCHECK_FOR_STACK_OVERFLOW", &[0, 1, 2, 3]),
    ("configTICK_TYPE_WIDTH_IN_BITS", &[0, 1, 2]),
    ("configUSE_STATS_FORMATTING_FUNCTIONS", &[0, 1, 2]),
    ("configUSE_TASK_FPU_SUPPORT", &[0, 1, 2]),
];

fn main() {
    let bindings_path = PathBuf::from(env::var(FREERTOS_BINDINGS_LOCATION_ENV_KEY).unwrap());
    let bindings = fs::read_to_string(bindings_path).unwrap();
    emit_on_one(BOOLEAN_CONFIGS, &bindings);
    emit_value(VALUE_CONFIGS, &bindings);
}

/// Parses a config item from the bindings.
///
/// Panics on expected configuration entries not being present in the bindings.
fn parse_config(config: &str, bindings: &str) -> u64 {
    let regex = Regex::new(&format!("pub const {config}: [a-zA-Z0-9]* = ([0-9]*);")).unwrap();

    // FreeRTOS uses defaults for all configurations. If a configuration we check for isn't present, this indicates
    // a bug.
    let Some(matches) = regex.captures(bindings) else {
        panic!("configuration for \"{config}\" was not found");
    };

    let regex_match = matches.get(1).unwrap().as_str();

    println!("found \"{config}\": {regex_match}");

    regex_match.parse::<u64>().unwrap()
}

/// Emits `cfg`s for parsed configuration entries from the `FreeRTOSConfig.h` file.
///
/// Only supports the values `0` for "don't set `cfg`" and `1` for "set `cfg`".
/// For value support, see [`emit_value`].
///
/// This enables conditional inclusion of code that depends on the configuration of the FreeRTOS library.
///
/// # Panics
///
/// Panics on:
/// - values other than `0` or `1`.
/// - expected configuration entries not being present in the bindings.
fn emit_on_one(list: &[&str], bindings: &str) {
    for item in list {
        let value = parse_config(item, bindings);
        match value {
            0 => {}
            1 => println!("cargo::rustc-cfg={item}"),
            _ => panic!("value for \"{item}\" was neither \"0\" nor \"1\": {value}"),
        }

        println!("cargo::rustc-check-cfg=cfg({item}, values(none()))");
    }
}

/// Emits `cfg`s for parsed configuration entries from the `FreeRTOSConfig.h` file with their respective value.
///
/// For set or not-set cfg support, see [`emit_value`].
///
/// This enables conditional inclusion of code that depends on the configuration of the FreeRTOS library.
///
/// # Panics
///
/// Panics on:
/// - non-expected values.
/// - expected configuration entries not being present in the bindings.
fn emit_value(list: &[(&str, &[u64])], bindings: &str) {
    for (item, expected_values) in list {
        let value = parse_config(item, bindings);

        if !expected_values.contains(&value) {
            panic!("unexpected value for \"{item}\" was: {value}");
        }

        println!("cargo::rustc-cfg={item}=\"{value}\"");

        for expected_value in *expected_values {
            println!("cargo::rustc-check-cfg=cfg({item}, values(\"{expected_value}\",))");
        }
    }
}
